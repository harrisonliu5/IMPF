# es5

## 作用域

es5 只有函数级作用域

> 变量只会提到函数的最顶的，如果没有函数就提升到window；

> Javascript中的作用域就是词法作用域（事实上大部分语言都是基于词法作用域的）。

### try,with会延长作用域。

    let a = 1;
    try{
        throw 1;
    }catch(a){
        alert(a)
    }

with(obj)  如果obj里没有的,会变成全局变量,有的才会改变；

    var obj = {a:1};
    width(obj){
        obj.b = 2;
    }

    console.log(obj.b)   //undifined;

### 变量提升和函数提升

> 函数的优秀级比变量的优先级高；

函数声明会被提升 而函数表达式= 变量；

    a();  // 1;
    function a (){console.log(1)};
    var a = function(){console.log(2)};

## 闭包

> 闭包是内部函数可以访问外部变量，但外层函数不能访问内部变量。换句话说拿到本不该拿的东西。

    function test(){
        var k = 1000;
        return function(){
            return k
        }
    }
    var a = test()();
    console.log(a) //  1000;

> 闭包里有eval with try 变量不会被回收。

    function test(){
        var k = 1000;
        return function(){
            eval(""); //k是不会被收回
        }
    }

## this

> 谁调用的就值谁

### 闭包里的this

> 指的是window

    this.a = 1000;
    obj={
        a: 100,
        test: function(){
            alert(this.a);
            return function(){
                alert(this.a);
            }
        }
    }
    obj.test()();   // 1000
    ------------------------------
    var t = obj.test(); 
    t();                // 1000

### 构造函数

> this指的是自己。

    this.a = 1000;
    function test(){
        this.a = 1;
    }
    test.prototype.geta = function(){
        alert(this.a);
    }
    var p = new test;
    p.geta();       //1

### 箭头函数

> 箭头函数指向父级的this，也就是bind父级的this。

    this.a = 30;
    var obj = {
        a: 30,
        init: ()=>{
            alert(a) // 30
        }
    }
    obj.init();

js单线程是为了操作dom