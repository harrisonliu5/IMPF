# 函数式编程

函数式编程起源是范畴论的数学分支。

1.函数式一等公民。
是函数与其他数据类型一样
函数式编程里变量不能被修改，所有的变量只能被赋值一次
2.函数只用表达式，不用语句 （if）
3.没有副作用
4.不修改状态

## 范畴

> 范畴就是一个类或者一个集合。里面有成员和态射。

范畴成员之间的关系叫做"态射"。
同一个范畴的所有成员，就是不同状态的"变形。
可以通过"态射"，一个成员可以变形成另一个成员。

范畴可以当做一个容器，里面有值和变形关系。

值：value，
态射：函数。

    class Category{                         //范畴-容器
        constructor(val){
            this.val = val;                   //成员-值
        }
        add(x){                               //态射-函数
            return x+1;
        }
    }

## 纯函数

本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法。

所以需要纯的，不能有副作用，因为函数运算原始目的就是求值。输入值 输出一个新值，没有其他作用。

不仅可以有效降低系统的复杂度，还有很多很棒的特性，比如可缓存性。

### 函数组合

一个需要经过多个函数变成另一个值，就可以把中间所有步骤合并成一个函数。这个叫函数合成。

    const compose = (f,g)=>x=>f(g(x));
    const compose = function(f,g){
        return function(x){
            return f(g(x));
        }
    }

a -(f)- b -(g)- c-(h)- d

    compose(f,compose(g,h)) = compose(compose(f, g), h) = compose(f, g, h)


## 柯里化

f(x)和g(x) 合成 f(g(x)),有一个前提，就是f和g只能接受一个参数。

所以柯里化就是把一个多参数的函数转化为单参数的函数。

    var checkage = min => age => age > min;
    var result = checkage(18);
    result(20)

是一种“预加载”函数的方法

## 函子

函子是函数式编程里最重要的数据类型，也是基本的运算单位和功能单位。

一个容器，通过变形关系将成员变形成为了另一个容器的成员，这个容器就是函子。


### 函子的代码实现

    class Functor{                  //函子
        constructor(val){
            this.val = val;
        }
        map(f){
            return new Functor(f(this.val));
        }
    }

函子的标志就是容器具有map方法，该方法就是将容器里的每个值，映射到另一个容器。
map接受的是一个函数。

### of方法

生成新的函子的时候，用了new ，这个不像函数式编程。所以就有了of。

    Functor.of= function(val){
        return new Functor(val);
    }

函子的写法

    class Functor{                  //函子
        constructor(val){
            this.val = val;
        }
        map(f){
            return Functor.of(f);
        }
    }

    Functor.of= function(val){
        return new Functor(val);
    }

### Maybe函子

    class Maybe extends Functor{
        map(f){
            return this.val ? Maybe.of(f(this.val)):Maybe.of(null);
        }
    }

### Either函子

    class Either extends Functor{
        constructor(left,right){
            this.left = left;
            this.right = right;
        }
        map(f){
            return this.right
                ? Either.of(this.left,f(this.right))
                : Either.of(f(this.left),this.right)
        }
    }
    Either.of = (left,right) => new Either(left,right);


### ap 函子

    class Ap extends Functor {
        ap(F) {
            return Ap.of(this.val(F.val));
        }
    }

    function add(x) {
        return function (y) {
            return x + y;
        };
    }

    Ap.of(add(2)).ap(Maybe.of(3));

### Monad函子

Monad 函子的作用是，总是返回一个单层的函子。

    class Monad extends Functor {
        join() {
            return this.val;
        }
        flatMap(f) {
            return this.map(f).join();
        }
     }

### IO 操作

I/O 是不纯的操作，普通的函数式编程没法做，这时就需要把 IO 操作写成Monad函子，通过它来完成。