# js原生方法源码

## call (this,参数1，参数2，...)

```javascript
Function.prototype.myCall = function(context,...parameter){
	
    // 判断当前的是否为 function;
    if(typeof context !== 'function'){
        throw new TypeError('Error');   
    }
    
    // 如果是 null 或者 undefined;   
    context = context || window;
    
    // 声明一个 Symbol 属性，防止 fn 被占用
    let fn = Symbol('fn');
    
    // 将当前的 this 也是当前的函数赋予contex的一个属性;
    context[fn] = this;
    
    // 执行该属性
   	let res = context[fn](...parameter)
    
    // 删除 context 对象上的 fn 属性
    delete context[fn];
    
    return res;
}
```

## apply(this, [参数1，参数2])

```js
Function.prototyppe.myApply = function(context, parameter){
	if(typeof context !== 'function'){
        throw new Error('不是函数类型');
    }
   	context = context || window;
    let fn = Symbol('fn');
    context[fn] = this;
    let res =  context[fn](parameter);
    delete context[fn];
    return res;
}
```

## bind(this,参数1，参数2) 不会立刻执行

```js
Function.prototype.myBind = function(context, ...parameter){
    // 保存当前的this
    let _this = this;
    
	return function(...nextParameter){
		return _this.call(context, ...parameter,...nextParameter);
	}
}

// 第二种
Function.prototype.mybind = function(context, ...parameter) {
    if (typeof this !== 'function') {
      throw TypeError("Bind must be called on a function");
    }
      // 保存 this
      self = this,
      // 构建一个干净的函数，用于保存原函数的原型
      nop = function() {},
      // 绑定的函数
      bound = function() {
        // this instanceof nop, 判断是否使用 new 来调用 bound
        // 如果是 new 来调用的话，this的指向就是其实例，
        // 如果不是 new 调用的话，就改变 this 指向到指定的对象 o
        return self.apply(
          this instanceof nop ? this : context,
          ...parameter
        );
      };

    // 箭头函数没有 prototype，箭头函数this永远指向它所在的作用域
    if (this.prototype) {
      nop.prototype = this.prototype;
    }
    // 修改绑定函数的原型指向
    bound.prototype = new nop();

    return bound;
  }

```

## new 

```js
function myNew(context,...parameter){
    
    // 创建一个新的对象
    let obj = new Object{};
    
    // 将当前context的原型赋予新的对象上。
    obj.__proto__ = context.prototype;
    
    // 更改当前的this
    let ret = context.call(obj, ...parameter);
    
    // 当contex有返回值并且是对象的时候 返回新建的obj对象。
    return typeof ret === 'object'? obj : ret;
}
```

