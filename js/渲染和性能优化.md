# 性能优化

## 雅虎军规

1. 尽量减少HTTP请求数 
2. 减少DNS查找
3. 避免重定向
4. 让Ajax可缓存
5. 延迟加载组件
6. 预加载组件
7. 减少DOM元素的数量 
8. 跨域分离组件 
9. 尽量少用iframe
10. 杜绝404 
11. 避免使用CSS表达式 
12. 选择<link>舍弃@import 
13. 避免使用滤镜 
14. 把样式表放在顶部 
15. 去除重复脚本 
16. 尽量减少DOM访问 
17. 用智能的事件处理器 
18. 把脚本放在底部 
19. 把JavaScript和CSS放到外面 
20. 压缩JavaScript和CSS 
21. 优化图片
22. 优化CSS Sprite
23. 不要用HTML缩放图片 
24. 用小的可缓存的favicon.ico(P.S. 收藏夹图标) 
25. 给Cookie减肥 
26. 把组件放在不含cookie的域下 
27. 保证所有组件都小于25K 
28. 把组件打包到一个复合文档里
29. Gzip组件
30. 避免图片src属性为空
31. 配置ETags
32. 对Ajax用GET请求 
33. 尽早清空缓冲区(Bigpipe) 
34. 用CDN(内容分发网络) 
35. 添上Expires或者Cache-Control HTTP头

## 页面渲染

### 从url到页面渲染

 1. 用户输入网址回车后，浏览器进程接受URL地址，并转发给网络进程。
  2. 网络进程先查询当前url是否有缓存，并比价缓存是否过期。
  3. 网络进程发出URL请求，先跨越防火墙（网关、路由器、代理等-–防火墙可以理解成内网与外网之间一个设备）验证是否可以。
  4. 将域名通过DNS域名解析成IP，查找域名对应IP地址这一步才是request。
  5. 根据IP建立TCP(三次握手)。
  6. HTTP发起请求（请求的数据包在网络上进行传递，中间会碰到很多路由器进行转发到最终的服务器上，可以理解成驿站网络节点上-–拓普结构，到达服务器上后（服务器背后可能是一个集群多台服务器））。
  7. 服务器处理请求（通过IP地址找到正确的那一台服务器找到服务器后，接受到请求数据包以后，首先服务器解析这个请求(http协议层面)，把所有的数据抽取出来，在检查头是不是给它的，还有安全性上的一些东西，所有都通过了，服务器才response响应回去响应回去的给客户端的路上），
  8. 浏览器的网络进程接受HTTP响应（请求的链路和返回的链路未必是相同一条路（互联网络是一个复杂的结构，画的图数学叫图论，述说他的样子称之拓普结构）。
   9. 渲染进程将HTML解析DOM树。
   10. 加载JS脚本，图片和CSS等外部文件。
   11. 解析并执行JS脚本代码。
   12. 渲染引擎将CSS转换成styleSheets，计算节点的样式（分层和继承）。

    13. 通过styleSheets和DOM树创建布局树，并计算布局信息。
 14. 对布局树进行分层，生成图层树。
 15. 合成线程将图层分成图块，并在光栅化线程池中将图块转成位图。
 16. 合成线程发送绘制命令Draw Quad命令给浏览器进程。
 17. 浏览器进程根据Draw Quad消息渲染页面。
 18. 页面加载完成。
 19. 关闭TCP连接（四次挥手）

### 构建DOM树

> DOM树本质是一个以document为根节点的交叉树

当接口返回的数据类型为’text/html’时，浏览器会新开一个渲染进程，进行HTML的解析渲染。此时网络进程和渲染进程之间会形成一个数据通道，网络进程将数据放入通道一端，渲染进程在另一端获取数据进行解析。

HTML解析（HTML Parser） 分为：**字节流- 分词器-生成节点-DOM**。

字节流就是数据中的HTML标签。

分词器就是将字节流转化为**Token**，并在解析中维护一个**Token 栈**，主要是维护父子级的关系。

分词器和生成节点这两部是同时进行的。

- 分词器会将html的开头标签（**Start Tag**）进行标记，将标记压入Token栈中。此时会在DOM中生成对应的DOM节点。

- 遇到闭合标签（**End Tag**）将Token中中对应的标记进行弹栈，同时在DOM中将内容绑定到节点中。最后生成DOM。

#### JS 影响DOM生成

如何影响：

1. 当HTML解析到有`script`标签的时候，解析会暂停。运行JS的脚本，运行完在继续进行HTML解析。
2. JS的下载过程中会阻塞DOM。

这个就是为什么JS会阻塞DOM树的**渲染**。

怎么优化：

1. chrome增加了一个预解析的进程，在解析HTML时，会预先下载所需要的JS和CSS。这个和解析HTML是同步进行。

2. 使用CDN进行加速JS文件的加载，压缩JS文件的大小。

3. `script`使用`async`和`defer`,只是用于网络请求中。

   - async 是请求完成后直接可以执行，不被顺序影响。

   - defer 是请求完成后，按照顺序执行，在DOMContentLoaded和load之前执。
   - prefetch
   - preload

具体原因是：JS是可以操作CSS的，而遇到`script`时，浏览器会先确认CSS是否下载完成，解析完成，生成CSSOM（styleSheets）。所以是，**CSS阻塞了JS脚本的执行，但不影响JS的下载和解析，而JS脚本执行阻塞了DOM树的渲染。**

#### CSS如何影响首屏加载

在渲染进程里，构建DOM-构建CSSOM-执行JS-构建DOM-构建布局树（Layout）--图层树（Layer）-渲染。

通过构建CSSOM，来确定DOM树中节点的具体样式，但是不知道每个节点的几何位置，所以通过CSSOM和DOM向结合生成**布局树**。

而渲染进程需要为特定的节点生成专业的图层，并生成**图层树**。

合成线程通过图层树，将图层分为图块（tile），并按照视口附近为优先原则生成位图。生成位图的操作是由**光栅化**来执行。光栅化就是将图层转换为位图。

为什么需要CSSOM(styleSheets):

1. 提供JS操作CSS的能力。
2. 为布局树的合成提供基础样式。

#### CSS动画比JS高效

显示器的刷新率是60hz，就是每秒渲染60张图片。图片保存显卡中的**前缓存区域**，显示器每秒从前缓存区域读取图片。而显卡评率和显数器的频率一致，显卡的作用就是合成新图片，将合成的新图片放在**后缓存区域**。系统就会切换前后缓存区域进行显示。

**任意一帧的生成方式，有合成，重排和重绘三种。**

- 重排是更加DOM和CSSOM计算布局树。

- 重绘不重新布局。

- 合成是在合成线程里进行不阻塞主线程。

  

主线程 		DOM-Style-Layout-Layer-Print

合成线程	  											tiles-raster-draw quad

​																		|		 |

​																光栅化线程   |

​															GPU线程 <- 浏览器进程



JS写动画会影响整个渲染进程，所以比CSS动画效率低。

在元素上可以增加`will-change`来告诉合成线程进行处理。

## 浏览器加载分析

![](./optimization.png)



1. 对我们比较有用的页面性能数据大概包括如下几个:

   - DNS查询耗时、TCP链接耗时、request请求耗时、解析dom树耗时、白屏时间、domready时间、 onload时间等，而这些参数是通过上面的performance.timing各个属性的差值组成的，计算方法 如下:

   - DNS查询耗时 :domainLookupEnd - domainLookupStart TCP链接耗时 :connectEnd - connectStart   .

   - request请求耗时 :responseEnd - responseStart .

   - 解析dom树耗时 : domComplete- domInteractive   

   - 白屏时间 :responseStart - navigationStart   

   - domready时间 :domContentLoadedEventEnd - navigationStart   

   - onload时间 :loadEventEnd - navigationStart   

   - NavigationTiming的目的是用于分析页面整体性能指标。如果要获取个别资源(例如JS、图片) 的性能指标，就需要使用Resource Timing API。   

2. 打点请求数据 要用navigator.sendBeacon(“日志请求地址”)发送，因为它是等主渲染进程不 忙的时候进行发送。做埋点最怕的就是影响主进程。   

## 框架渲染对比

|      | CSR                                                          | 预渲染                                                       | SSR                                                  | 同构                                                         |
| ---- | :----------------------------------------------------------- | ------------------------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| 优点 | 1. 不依赖数据。<br/>2. FP时间最快。<br/>3. 客户端用户体验好。<br/>4. 内存数据共享。 | 1. 不依赖数据。<br/>2. FCP比CSR快。<br/>3. 客户端用户体验好。<br/>4. 内存数据共享。 | 1. SEO友好。<br/>2. 首屏性能高、FMP比CSR和预渲染快。 | 1. SEO友好。<br/>2. 首屏性能高、FMP比CSR和预渲染快。<br/>3. 客户端用户体验好。<br/>4. 内存数据共享。<br/>5. 客户端与服务端代码公用，开发效率高 |
| 缺点 | 1. SEO不友好。<br/>2.FCP、FMP慢。                            | 1. SEO不友好。<br/>2.FMP慢。                                 | 1. 数据端数据共享成本高。<br/>2.模板维护成本高。     | 1. Node的稳定性稍差。                                        |

### 预渲染原理

先起一个无头浏览器（Rize.js），将页面渲染完成后的html下载下来，运行到当前的浏览器。

P.S. 

- **FP ( first-plain ) ** 是首次渲染.
- **FCP ( first-content-plain )**是首次内容渲染。当body里有内容时渲染的时间，如果body里只有空标签而没有内容则不会触发。
- **FMP**是首次整个页面渲染。