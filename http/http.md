# HTTP

[TOC]

## HTTP传输

![http传输](.\http-transform.png)

HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

__以下是 HTTP 请求/响应的步骤：__

   1.  客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。
   2. 发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。
   3. 服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。
   4. 释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。
   5. 客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

## HTTP协议详解

### http协议的发展

HTTP就超文本传输协议，网站就是基于http协议（图片，css，JS）传输的，HTTP协议是由从客户机到服务器的请求request和从服务器到客户机的响应response进行约束和规范。


- 0.9版本 早期HTTP只有二个方法**get**和**post**。
- 1.0版本 多了一个方法**HEAD**(请求获取 响应消息报头)无法复用链接，完成即断开，重新慢启动和 TCP 3次握手，head of line blocking: 线头阻塞，导致请求之间互相影响。
- 1.1版本一共有五个方法 **get**  **post**  **put**  **delete**  **head**  另有(**trace**  **connect**  **options**)长，连接(默认 keep-alive)，复用host 字段指定对应的虚拟站点新增功能，断点续传，身份认证，状态管理，cache 缓存。  
- 2.0多路复用二进制分帧层: 应用层和传输层之间首部压缩，服务端推送，HTTP之状态码，

### http状态码

- 1xx：指示信息--表示请求已接收，继续处理。
- 2xx：成功--表示请求已被成功接收、理解、接受。
    204：请求被受理理但没有资源可以返回 。
    206：客户端只是请求资源的⼀一部分，服务器器只对请求的部分资源执⾏行行GET⽅方法，相应报⽂文中通过 Content-Range指定范围的资源。
- 3xx：重定向--要完成请求必须进行更进一步的操作。
    301：永久性重定向302：临时重定向。
    303：与302状态码有相似功能，只是它希望客户端在请求⼀一个URI的时候，能通过GET⽅方法重定向到另⼀一个URI上。
    304：发送附带条件的请求时，条件不不满⾜足时返回，与重定向⽆无关。
    307：临时重定向，与302类似，只是强制要求使⽤用POST⽅方法，还缓存策略也会遇到提示。
- 4xx：客户端错误--请求有语法错误或请求无法实现 。
    400：请求报⽂文语法有误，服务器器⽆无法识别 。
    401：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 。
    403：请求的对应资源禁⽌止被访问。
    404：Not Found 请求资源不存在。
    403：Forbidden 权限不够。
    405：Method Not Allowed 请求方法不被允许。
- 5xx：服务器端错误--服务器未能实现合法的请求 。
    500：服务器发生不可预期的错误 。
    502：请求到了反向代理了，但是反向代理不过去指定服务器。
    503：服务器当前不能处理客户端的请求，一段时间后可能恢复正常请求报头详细字段request。 

## Http相关组件

### 网络模型

![](.\http-5.png)

#### 基本模型

- 应用层：为应用程序提供所需要的各种服务、例如：**http**、**ftp**、**DNS**、**SMTP**等
- 传输层：四层交换机、四层路由器为应用层实体提供端到端的通信功能，保证数据包顺序传送及数据的完整性，该层定义了两个主要的协议：**传输控制协议TCP**和**用户数据报协议UDP**。
  - **TCP**：提供了面向连接的服务，保证并确认报文是否到达，并提供了拥塞机制来控制网络传输，因此当网络拥塞时，会抑制其网络传输速率。
  - **UDP**：向它的应用提供无连接服务。它不具备可靠性的特征，没有流量控制，也没有拥塞限制。我们把传输层的分组成为`报文段（segment）`。
- 网络层：路由器、三层交换机。主要解决主机到主机的通信问题。 **IP协议**是网际互联层最重要的协议。
- 数据链路层：为了将分组从一个节点（主机或路由器）运输到另一个节点，网络层必须依靠链路层提供服务。链路层包括以太网、WiFi 和电缆接入的 `DOCSIS` 协议，因为数据从源目的地传送通常需要经过几条链路，一个数据包可能被沿途不同的链路层协议处理，我们把链路层的分组称为 `帧(frame)`
- 物理层：关于双绞铜线、关于同轴电缆、关于光纤等等。

#### OSI网络模型

![](.\http-osi.png)

      1. 应用层：为应用程序提供服务&gt;软件调用
      2. 表示层：数据格式转换，数据加密
      3. 会话层：建立、管理和维护会话（对应主机进程，指本地主机与远程主机正在进行的会话）
      4. 传输层：建立、管理和维护端到端的连接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。
      5. 网络层：IP选址及路由选择，本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。
      6. 数据链路层：提供介质访问和链路管理（网卡以内，硬件MAK地址属于数据链路层）。
      7. 物理层：中继器、集线器、双绞线，实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电kkd平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。

### CDN

CDN的全称是`Content Delivery Network`，即`内容分发网络`，它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户`就近`获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有`内容存储`和`分发技术`。

### WAF

WAF 是一种 Web 应用程序防护系统（Web Application Firewall，简称 WAF），它是一种通过执行一系列针对HTTP / HTTPS的`安全策略`来专门为Web应用提供保护的一款产品，它是应用层面的`防火墙`，专门检测 HTTP 流量，是防护 Web 应用的安全技术。

WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。

## Http相关的协议

### TCP/IP

`TCP/IP` 协议你一定听过，TCP/IP 我们一般称之为`协议簇`，就是 TCP/IP 协议簇中不仅仅只有 TCP 协议和 IP 协议，它是一系列网络通信协议的统称。而其中最核心的两个协议就是 TCP / IP 协议，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。

TCP 协议的全称是 `Transmission Control Protocol` 的缩写，意思是`传输控制协议`，HTTP 使用 TCP 作为通信协议，这是因为 TCP 是一种可靠的协议，而`可靠`能保证数据不丢失。

IP 协议的全称是 `Internet Protocol` 的缩写，它主要解决的是通信双方寻址的问题。IP 协议使用 `IP 地址` 来标识互联网上的每一台计算机，可以把 IP 地址想象成为你手机的电话号码，你要与他人通话必须先要知道他人的手机号码，计算机网络中信息交换必须先要知道对方的 IP 地址。

### DNS

把 IP 地址转换为便于人类记忆的协议就是 `DNS 协议`。

DNS 的全称是`域名系统（Domain Name System，缩写：DNS）`，它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。

### URI / URL

你输入的地址格式必须要满足 `URI` 的规范。

`URI`的全称是（Uniform Resource Identifier），中文名称是统一资源标识符，使用它就能够唯一地标记互联网上资源。

`URL`的全称是（Uniform Resource Locator），中文名称是统一资源定位符，也就是我们俗称的`网址`，它实际上是 URI 的一个子集。

**URI** 包含 **URL** 和 **URN**（统一资源名称）。

## 请求报头字段

### http 1.1 请求字段：

1. Accept：text/html;charset=utf-8 指定客户端接受哪些类型的信息（响应字段Content-Type对应）
2. Accept-Encoding：gzip 服务器支持压缩，请求报头域类似于Accept，但是它是用于指定可接受的内容编码。
3. Accept-Language：zh-CN,zh 指定一种自然语言，zh-CN语言Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。
4. Connection：keep-alive 服务器支持长链接。
5. Cookie：Host：sp0.baidu.com 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，发送请求时，该报头域是必需的。

6. Referer：https://www.baidu.com/ 你的请求来源路径，不是指定来源的不给访问。
7. User-Agent：Mozilla/5.0 (Windows NT 6.1; WOW64) 请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。

### http2.0请求头字段:

1. authority：ke.qq.com 请求认证部份。

2. method: GET 目标URL模式（请求）。
3. path： 请求链接对应服务器目录。
4. scheme: https 目标URL模式（请求）。
5. host字段。
6. status 状态码。
7. response 响应报头字段。
8. Accept-Ranges：bytesCache-Control:max-age=0 缓存策略。
9. Connection：keep-alive 服务支持长链接（不支持就没有这一行），和请求报头字段一一对应。
10. Content-Encoding：gzip 浏览器支持压缩，指定内容编码。
11. Content-Type：text/html;charset=utf-8 返回给页面内容的描述，是html还是图片等，以及编码。
12. Date：Thu, 22 Nov 2018 05:04:17 GMT 服务器响应时间（给缓存用的）国际标准时间。	
13. GMTExpires：Thu, 22 Nov 2018 05:04:17 GMT 缓存的有效时间（给缓存用的）。
14. Server：nodejs/1.0 这是说服务器用的是什么环境/版本。

## HTTPS协议  = HTTP+ 加密 + 认证 + 完整性保护

分析它拥有和http协议的所有功能，但是他安全性却高了，因为他在加密 .

> HTTPS并非是应用层的一种新协议，只是HTTP通信接口部分用SSL和TLS协议代替，

　HTTPS 是身披 SSL 外壳的 HTTP

![](.\https-img1.png)

### SSL

SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。

**HTTP采用共享密钥加密和公开密钥加密两者并用的混合加密机制。**

![](.\https-img2.png)

HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。

SSL 的慢分两种：一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源，导致处理速度变慢。

### 不使用https的原因

1. 与纯文本通信相比，加密通信会消耗更多CPU和内存资源。
2. 需要额外支付证书的费用。

### HTTP2优点

1. 多路路复⽤用允许同时通过单⼀一的 HTTP/2 连接发起多重的请求-响应消息。⽐比原⽹网站提升6倍。

2. 头部压缩。在应用层(HTTP/2)和传输层(TCP or UDP)之间增加了一个二进制分帧层。突破 HTTP1.1 的性能限制，改进传输性能，实现低延迟和⾼高吞吐量量。   

3. HTTP2服务端推送(Server Push)。


### HTTP不足

- 通信使用明文（不加密），内容可能会被窃听。
- 不验证通信方的身份，因此可能被伪造。
- 无法证明报文的完整性，所以有可能已遭篡改。

## HTTP缓存

> 缓存策略: 可分为 强缓存 和 协商缓存

<img src="./cache.png" style="zoom:150%;" />

### 强缓存

浏览器中缓存分两种，一种需要__http__请求，一种不需要。

在验证强缓存时，不用发送http请求。

在<span style="color:red">`HTTP/1.0`</span>时期用的是__Expires__，<span style="color:red">`HTTP/1.1`</span>时期用__Cache-Control__

#### Expires

__Expires__ 即过期时间 ，存在服务端返回的响应头中，告诉浏览器在这个过期时间都可以直接从缓存里面获取数据，无需再次请求。

```javascript
Expires Wed, 22 Nov 2019 08:41:00 GTM
```

表示资源在这个时间段过期，过期了就需要向服务端发请求。

这个方式有个问题就是__服务器的时间和浏览器的时间可能并不一致__，就会导致这个时间不准确所以被HTTP1.1版本抛弃。

#### Cache-Control

HTTP1.1中使用使用。

和__Expires__的本质不同在与没有采用<span style="color:red">`具体的过期时间点`</span>，而是采用过期时长来控制缓存，对应的字段是__max-age__。

```javascript
Cache-Control:max-age=3600
```

代表响应返回后在 3600 秒内可以直接使用缓存。

Cache-Control有其他字段：

__private__：这种情况就是只有浏览器能缓存，中间代理服务器不能缓存。

__no-cache__：跳过当前的强缓存，发送HTTP请求，直接进入__协商缓存阶段__。

__no-store__：非常粗暴，不进行任何形式的缓存。

__s-maxage__： 这和__max--age__长的比较像，区别在于s-maxage是针对服务器的缓存时间，用以多位用户使用的公共缓存服务器，对同一个用户重复返回响应的服务器没有作用。另外 s-maxage 会忽略Expires 及max-age。

当__Expires__和__Cache-Control__同时存在的时候，__Cache-Control__会优先考虑。

### 协商缓存

强缓存失效后，浏览器在请求头携带相应的__缓存tag__来想服务器发请求，由于服务器根据这个tag来决定是否使用缓存，这个就是__协商缓存__。

缓存tag分为两种：__Last-Modified__和__ETag__，他们不存在绝对优势。

#### Last-Modified

即最后修改时间，在浏览器第一次给服务器发请求后，服务器会在响应头中加这个字段。

浏览器如果再次请求，会在请求头上携带<span style="color:red">`If-Modified-Since`（request）</span>字段，这个字段的值也就是服务器传来的__Last-Modified（response）__最后修改时间。

服务器拿到这个字段后悔和服务器中该资源最后修改时间对比：

- 如果请求头的这个值小于最后修改时间，返回新的资源。
- 否则返回304，直接用缓存。

#### ETag

<span style="color:red">`ETag`</span>是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。

浏览器收到__ETag（response）__值，在下次请求时，将这个值作为__if-None-Match（request）__这个字段的内容，并发到请求头中，发给服务器。

服务器收到__If-None_Match__后，会跟服务器上改资源的ETag进行对比：

- 如果两者不一样，说明要更新，返回新的资源,并且__Last-Modified__的值为__If-None_Match__。
- 否则返回304，告诉浏览器使用缓存。

#### 两者对比

1. 在精准上，ETag优于Last-Modified.因为ETag是按照内容给资源上标识，因此能准确感知资源的变化，而Last-Modified就不一样，它在一些特殊情况下并不能感知。主要有两个情况：
   -  编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。 
   - 最小粒度只到 s， s 以内的改动无法检测到，原因是 UNIX记录MTIME只能精确到秒。
2. 在性能上，`Last-Modified`优于`ETag`，也很简单理解，`Last-Modified`仅仅只是记录一个时间点，而 `Etag`需要根据文件的具体内容生成哈希值。 

 另外，如果两种方式都支持的话，服务器会优先考虑`ETag`。 

### 缓存位置

浏览器位置一共有四种，按优先级从高到底排列分别是：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

#### Service Worker

 它能帮助我们完成很多有用的功能，比如`离线缓存`、`消息推送`和`网络代理`等功能。其中的`离线缓存`就是 **Service Worker Cache**。 

 Service Worker 同时也是 PWA 的重要实现机制 

#### Memory Cache 和 Disk Cache

 **Memory Cache**指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。 

 **Disk Cache**就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。

既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：

- 比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存。
- 内存使用率比较高的时候，文件优先进入磁盘、

#### Push Cache

 即推送缓存，这是浏览器缓存的最后一道防线。它是 `HTTP/2` 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。 [扩展文章]( https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/ )

### 浏览器缓存总结

先看是否有缓存，如果没有则直接由服务器返回。

通过Cache-Control 验证强缓存是否可用。如果可用，直接使用。

否则进入协商请求，即发送HTTP请求。服务器在通过请求头中的__`ETag`__ 或者__`Last-Modified`__字段是否更新

- __有 `if-Noe-Match`（ ETag ）和`If-Modified-Since`（ Last-Modified ）__则要验证
  - If-None-Match === ETag
  - if-Modified-Since === Last-Modified

- __只有If-None-Match__则验证
  - If-None-Match === ETag
- __只有If-Modified-Since__则验证
  - if-Modified-Since === Last-Modified

如果失效返回新的内容，浏览器缓存，展示新的内容。 

否则返回304，浏览器缓存会更新缓存文档的新鲜度，构造响展示缓存内容  。



## 从url到页面发生了什么

      1. 用户输入网址回车后（发送一个指令）
      2. 浏览器先查询当前url是否有缓存，并比价缓存是否过期。
      3. 先跨越防火墙（网关、路由器、代理等--防火墙可以理解成内网与外网之间一个设备）验证是否可以 。
   4. 将域名通过DNS域名解析成IP，查找域名对应IP地址这一步才是request
   5. 根据IP建立TCP(三次握手)。
   6. HTTP发起请求（请求的数据包在网络上进行传递，中间会碰到很多路由器进行转发到最终的服务器上，可以理解成驿站网络节点上--拓普结构，到达服务器上后（服务器背后可能是一个集群多台服务器））。
   7. 服务器处理请求（通过IP地址找到正确的那一台服务器找到服务器后，接受到请求数据包以后，首先服务器解析这个请求(http协议层面)，把所有的数据抽取出来，在检查头是不是给它的，还有安全性上的一些东西，所有都通过了，服务器才response响应回去响应回去的给客户端的路上），
   8. 浏览器接受HTTP响应（请求的链路和返回的链路未必是相同一条路（互联网络是一个复杂的结构，画的图数学叫图论，述说他的样子称之拓普结构）当数据返回到客户端后，浏览器进行处理解析（html，js，图片等等））
   9. 浏览器进行渲染给页面，构建DOM树
   10. 关闭TCP连接（四次挥手）
   11. 加载外部脚本和样式
   12. 解析并执行脚本代码
   13. 构造HTML DOM模型
   14. 加载图片等外部文件
   15. 页面加载完成
   16. 建树 


### 构建DOM树

> DOM树本质是一个以document为根节点的交叉树

**我们应该清楚把握一点: HTML 的文法并不是`上下文无关文法`。** 

 通俗一点讲，`上下文无关的文法`就是说这个文法中所有产生式的左边都是一个非终结符。 

#### 解析算法

HTML解析算法分为两个阶段

1. 标记化
   1. 对应的两个过程就是**词法分析**和**语法分析**。

**标记化过程**

1. 遇到`<`, 状态为**标记打开**。
2. 接收`[a-z]`的字符，会进入**标记名称状态**。
3. 这个状态一直保持，直到遇到`>`，表示标记名称记录完成，这时候变为**数据状态**。
4. 接下来遇到`body`标签做同样的处理。
5. 这个时候`html`和`body`的标记都记录好了。
6. 现在来到<body>中的>，进入**数据状态**，之后保持这样状态接收后面的字符**hello sanyuan**。
7. 接着接收 </body> 中的`<`，回到**标记打开**, 接收下一个`/`后，这时候会创建一个`end tag`的token。
8. 随后进入**标记名称状态**, 遇到`>`回到**数据状态**。
9. 接着以同样的样式处理 </body>。

#### 建树算法

解析器会创建一个document对象。标记生成器会把每个标记信息发给建树器，建树器接收到相应的标记时，会创建对应的DOM对象。创建这个DOM对象后会做两件事：

```
1. 将DOM对象加入DOM树种
```
 	2. 将对应标记压入存放开放（与闭合标签意思对应）元素的栈中。

### DNS解析域名

<img src="./dns.png" />





