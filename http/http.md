# HTTP工作原理

### HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。

HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

__以下是 HTTP 请求/响应的步骤：__

   1.  客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。
   2. 发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。
   3. 服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。
   4. 释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。
   5. 客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

### 从url到页面发生了什么 

   1. 用户输入网址回车后（发送一个指令），先跨越防火墙（网关、路由器、代理等--防火墙可以理解成内网与外网之间一个设备）验证是否可以 。
   2. 将域名通过DNS域名解析成IP，查找域名对应IP地址这一步才是request。
   3. 请求的数据包在网络上进行传递，中间会碰到很多路由器进行转发到最终的服务器上，可以理解成驿站网络节点上--拓普结构，到达服务器上后（服务器背后可能是一个集群多台服务器）。
   4. 通过IP地址找到正确的那一台服务器找到服务器后，接受到请求数据包以后，首先服务器解析这个请求(http协议层面)，把所有的数据抽取出来，在检查头是不是给它的，还有安全性上的一些东西，所有都通过了，服务器才response响应回去响应回去的给客户端的路上，
   5. 请求的链路和返回的链路未必是相同一条路（互联网络是一个复杂的结构，画的图数学叫图论，述说他的样子称之拓普结构）当数据返回到客户端后，浏览器进行处理解析（html，js，图片等等）最后浏览器进行渲染给页面，这时候客户就能看到页面


​    
### http协议详解

HTTP就超文本传输协议，网站就是基于http协议（图片，css，JS）传输的，HTTP协议是由从客户机到服务器的请求request和从服务器到客户机的响应response进行约束和规范。


- 0.9版本 早期HTTP只有二个方法get和post。

- 1.0版本 多了一个方法HEAD(请求获取 响应消息报头)无法复用链接，完成即断开，重新慢启动和 TCP 3次握手head of line blocking: 线头阻塞，导致请求之间互相影响。

- 1.1版本一共有五个方法 get  post  put  delete  head  另有(trace  connect  options)长连接(默认 keep-alive)，复用host 字段指定对应的虚拟站点新增功能:断点续传身份认证状态管理cache 缓存Cache-ControlExpiresLast-ModifiedEtag。       

- 2.0多路复用二进制分帧层: 应用层和传输层之间首部压缩服务端推送HTTP之状态码状态代码有三位数字组成，第一个数字定义了响应的类别,共分五种类别:
   - 1xx：指示信息--表示请求已接收，继续处理
   - 2xx：成功--表示请求已被成功接收、理解、接受
       204：请求被受理理但没有资源可以返回            
       206：客户端只是请求资源的⼀一部分，服务器器只对请求的部分资源执⾏行行GET⽅方法，相应报⽂文中通过 Content-Range指定范围的资源。
   - 3xx：重定向--要完成请求必须进行更进一步的操作
       301：永久性重定向302：临时重定向
       303：与302状态码有相似功能，只是它希望客户端在请求⼀一个URI的时候，能通过GET⽅方法重定向到另⼀一个URI上
       304：发送附带条件的请求时，条件不不满⾜足时返回，与重定向⽆无关
       307：临时重定向，与302类似，只是强制要求使⽤用POST⽅方法，还缓存策略也会遇到提示
       3xx，例如：你向服务器请求缓存，服务器告诉你向本地缓存获取
   - 4xx：客户端错误--请求有语法错误或请求无法实现      
       400：请求报⽂文语法有误，服务器器⽆无法识别        
       401：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用        403：请求的对应资源禁⽌止被访问        
       404：Not Found 请求资源不存在       
       403：Forbidden 权限不够        
       405：Method Not Allowed 请求方法不被允许
   - 5xx：服务器端错误--服务器未能实现合法的请求       
       500：服务器发生不可预期的错误       
       502：请求到了反向代理了，但是反向代理不过去指定服务器      
       503：服务器当前不能处理客户端的请求，一段时间后可能恢复正常请求报头详细字段request 
            
### 请求报头字段

Accept:text/html;charset=utf-8 指定客户端接受哪些类型的信息（响应字段Content-Type对应）
Accept-Encoding:gzip 服务器支持压缩，请求报头域类似于Accept，但是它是用于指定可接受的内容编码。
Accept-Language:zh-CN,zh 指定一种自然语言，zh-CN语言Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。
Connection:keep-alive 服务器支持长链接
Cookie:Host:sp0.baidu.com 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，发送请求时，该报头域是必需的。

Referer:https://www.baidu.com/ 你的请求来源路径，不是指定来源的不给访问
User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64) 请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。收集隐私信息--&gt;&gt;

-----------------------------------------------------------------------------------------
http2.0请求头字段（之前版本最顶层的HTTP/1.1 200 OK 对应）:
authority:ke.qq.com 请求认证部份:

method:GET 目标URL模式（请求）:
		path:/ 请求链接对应服务器目录:
		scheme:https 目标URL模式（请求）
		host字段:
		status 状态码
		response 响应报头字段
		Accept-Ranges:bytesCache-Control:max-age=0 缓存策略
		Connection:keep-alive 服务支持长链接（不支持就没有这一行），和请求报头字段一一对应
		Content-Encoding: gzip 浏览器支持压缩，指定内容编码
		Content-Type:text/html;charset=utf-8 返回给页面内容的描述，是html还是图片等，以及编码
		Date:Thu, 22 Nov 2018 05:04:17 GMT 服务器响应时间（给缓存用的）国际标准时间
		GMTExpires:Thu, 22 Nov 2018 05:04:17 GMT 缓存的有效时间（给缓存用的）
		Server:nodejs/1.0 这是说服务器用的是什么环境/版本

------------------------------------------------------------------------------------------------

### HTTPS协议  = HTTP+ 加密 + 认证 + 完整性保护

分析它拥有和http协议的所有功能，但是他安全性却高了，因为他在加密 .

> HTTPS并非是应用层的一种新协议，只是HTTP通信接口部分用SSL和TLS协议代替，

　HTTPS 是身披 SSL 外壳的 HTTP

![](.\https-img1.png)

#### SSL

SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。

**HTTP采用共享密钥加密和公开密钥加密两者并用的混合加密机制。**

![](.\https-img2.png)

#### TCP、IP协议栈TCP/IP五层模型

了解TCP、IP协议栈TCP/IP五层模型:

- 应用层：为应用程序提供所需要的各种服务、例如：http、ftp、DNS、SMTP等

- 传输层：四层交换机、四层路由器为应用层实体提供端到端的通信功能，保证数据包顺序传送及数据的完整性，该层定义了两个主要的协议：传输控制协议TCP和用户数据报协议UDP。

- 网络层：路由器、三层交换机。主要解决主机到主机的通信问题。IP协议是网际互联层最重要的协议

- 数据链路层：网桥、以及网交换机、网卡网卡以内，硬件MAK地址都属于。

- 物理层：中继器、集线器、双绞线

ISO标准化组织更细分化了里面的
   1. 应用层：为应用程序提供服务&gt;软件调用

   2. 表示层：数据格式转换，数据加密

   3. 会话层：建立、管理和维护会话（对应主机进程，指本地主机与远程主机正在进行的会话）

   4. 传输层：建立、管理和维护端到端的连接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。

   5. 网络层：IP选址及路由选择，本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。

   6. 数据链路层：提供介质访问和链路管理（网卡以内，硬件MAK地址属于数据链路层）

   7. 物理层：中继器、集线器、双绞线，实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电kkd平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质

      ------------------------------------

### TCP运输连接的三个阶段：

   1、连接建立
   		2、数据传送
   		3、连接释放建立TCP连接（HTTP协议握手流程）

   #### 三次握手
   第一次握手：建立连接时，客户端发送syn包（syn=1） 随机产生一个值seq=x到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。初始序号seq=x（seq是数据包本身的序列号）。SYN报文段不携带数据，但要消耗一个序号

   。第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（SYN seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态（服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态）

   第三次握手：客户端收到服务器的SYN+ACK包，检查是ACK相应值时，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据



   #### 四次挥手，所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开
1. 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

2. 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

3. 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

4. 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

   > 由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭

### HTTP2优点   
1. 多路路复⽤用允许同时通过单⼀一的 HTTP/2 连接发起多重的请求-响应消息。⽐比原⽹网站提升6倍   

2. 头部压缩。在应用层(HTTP/2)和传输层(TCP or UDP)之间增加了一个二进制分帧层。突破 HTTP1.1 的性能限制，改进传输性能，实现低延迟和⾼高吞吐量量。   

3. HTTP2服务端推送(Server Push)

   

### HTTP不足

- 通信使用明文（不加密），内容可能会被窃听。
- 不验证通信方的身份，因此可能被伪造。
- 无法证明报文的完整性，所以有可能已遭篡改。

### HTTP缓存

> 缓存策略: 可分为 强缓存 和 协商缓存

__注意：__

1. Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，

2. Cache-Control 的s-maxage指令和max-age的指令相同，只是用以多俄日用户使用的公共缓存服务器，对同一个用户重复返回响应的服务器没有作用。另外 s-maxage 会忽略Expires 及max-age。

3. Cache-Control的 max-age 优先级高于 Expires

4. 当缓存已经过期时，使用协商缓存唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，最后一次修改时间: Last-Modified(response)  

5. If-Modified-Since (request，上一次返回的Last-Modified)如果一致，则直接返回 304 通知浏览器使用缓存如不一致，则服务端返回新的资源

   -------------------------------------------------



__Last-Modified 缺点：__

1. 周期性修改，但内容未变时，会导致缓存失效
2. 最小粒度只到 s， s 以内的改动无法检测到
3. Etag 的优先级高于 Last-ModifiedEtag:

web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识(生成规则由服务器决定)

If-None-Match:当资源过期时(使用Cache-Control标识的max-age)，发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match (Etag的值)。web服务器收到请求后 发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。

Last-Modified:标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源 的最后修改时间。If-Modified-Since:当资源过期时(使用Cache-Control标识的max-age)，发现资源具有Last- Modified声明，则再次向web服务器请求时带上头If-Modified-Since，表示请求时间。

web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修 改时间较新，说明资源又被改动过，则响应整片资源内容(写在响应消息包体内)，HTTP 200; 若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器 继续使用所保存的cache。

#### Etag
主要为了解决Last-Modified无法解决的一些问题.他能比Last_Modified更加精确的知道文件是否被修改过.如果有个文件修改非常频繁，比如在秒以下的时间内进行修改，比如1秒 内修改了10次，If-Modified-Since能检查只能秒级的修改，所以这种修改无法判断. 原因是 UNIX记录MTIME只能精确到秒。

https://www.cnblogs.com/ranyonsue/p/5984001.html